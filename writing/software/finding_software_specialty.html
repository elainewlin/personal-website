<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Elaine Lin Portfolio</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="/assets/favicon.png" type="image/x-icon" />
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/main.css" />
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>

    <script>
      $(document).ready(function() {
        $(".navigation").load("/base/nav.html");
      });
    </script>
  </head>
  <body>
    <div id="header">
      <nav class="navigation"></nav>
    </div>
    <div class="container">
      <h2>Finding a Specialty in Software Engineering</h2>
      <p>
        Software companies have lots of jobs. When you're new to tech, it's hard to parse the
        flowery language of job descriptions to understand a) what different roles do at a
        high-level and b) what role is the best fit for you. In this post, I'm going to share some
        of my learnings from working as a software engineer.
      </p>
      <p>
        First, I'll describe the roles in EPD (engineering, product, and design) that you'll work
        with most often as a new-hire. Then, I'll dive into a software engineer role overview and
        what different types of engineers do at a high-level. Finally, I'll talk about how I decided
        to become a full-stack software engineer.
      </p>
      <ol>
        <li><a href="#roles-in-epd">Roles in EPD</a></li>
        <li><a href="#swe-role-overview">Software Engineer Role Overview</a></li>
        <li><a href="#types-of-swes">Types of Software Engineers</a></li>
        <li><a href="#why-fullstack">Why Full-stack for me?</a></li>
      </ol>
      <h3 id="roles-in-epd">Roles in EPD</h3>
      <p>The most common roles for new-hires are:</p>
      <ul>
        <li>
          Software engineer (sometimes abbreviated SWE)
        </li>
        <li>Product manager (PM)</li>
        <li>Designer</li>
      </ul>

      <p>
        For user-facing features, software engineers, PMs, and designers work closely together.
        You'll likely also have a manager. Here are some ways I interact with other roles:
      </p>
      <ul>
        <li>
          <b>PMs:</b> We go over product specs. A product spec describes why we're building a
          feature and clarifies requirements and priorities.
        </li>
        <li>
          <b>Designers:</b> We go over designs for features. Depending on the project stage, designs
          could be wireframes or full user flows. I consult design about user experience. After
          finishing my code, I set up a design review to compare the implemented and designed
          versions.
        </li>
        <li>
          <b>Manager:</b> We have a regular 1-on-1. This happens on a weekly or biweekly cadence. We
          talk about project progress, blockers, and career growth.
        </li>
      </ul>

      <p>
        I notice that PMs and managers have more meetings than software engineers. When choosing
        roles and career paths, think about how much you like facetime discussions vs. individual
        focus time.
      </p>

      <h3 id="swe-role-overview">Software Engineer Role Overview</h3>
      <p>
        As a software engineer, how do I spend my time at work? At a high-level, I write code, write
        words, and communicate with the team.
      </p>

      <p>
        I write code. At a company, the development process involves steps that you don't often find
        in personal projects.
      </p>
      <ol>
        <li>
          <b> Reviewing code</b>: Changes to the codebase must meet a certain level of quality and
          rigor. Other software engineers give you feedback on your code, and you can give feedback
          on other people's code. This is usually a prerequisite to deploying code.
        </li>
        <li>
          <b> Deploying code</b>: This is the process of getting your code out to users/clients.
          Depending on the project, the exact details and your level of involvement here vary. For
          instance, it's easier to deploy a website than a mobile app. Infrastructure and platform
          deploys look different from product deploys.
        </li>
        <li>
          <b> Maintaining code</b>: How can you make sure your code works for users? If you work on
          a website, and nobody can access the website, then an engineer has to step in to fix the
          issue. Typically, companies set up an on-call rotation: engineers take turns being on-call
          to maintain the code. You join this after you've been onboarded (depending on the company,
          this is ~6 months to 1 year after joining).
        </li>
      </ol>
      <p>I write words.</p>
      <ul>
        <li>
          For new projects, I write tech specs. A tech spec describes the high-level architecture
          decisions and their risks and trade-offs. This is useful for aligning on implementation
          with the team and documenting the project for the future.
        </li>
        <li>
          I write JIRA tickets for engineering tasks. JIRA is a project management software. It's
          useful for breaking down projects into smaller pieces.
        </li>
        <li>
          I write and edit documentation. It's useful to document common processes e.g. how to set
          up your workstation. This saves time for new engineers joining the team. Documentation
          also helps future engineers remember how to do certain tasks.
        </li>
      </ul>

      <p>I communicate with the team.</p>
      <ul>
        <li>
          I participate in meetings. For instance, I join a team weekly meeting to align on
          priorities and projects, and I join a company all-hands meeting for broader announcements
          and Q&amp;A.
        </li>
        <li>
          I send messages. Sometimes people have questions, or I have questions. Not knowing what to
          do is frustrating, and asking a teammate helps you get unstuck.
        </li>
      </ul>
      <h3 id="types-of-swes">Types of Software Engineers</h3>
      <p>
        There are many types of software engineers. Depending on your field, you may need to
        consider the software vs. hardware dimension of different roles. This is not my area of
        expertise, so I only talk about software.
      </p>

      <p>
        I'm a full-stack engineer. To understand what that means and what different types of
        engineers do, you need to understand what a
        <b>tech stack</b> is. A tech stack is the different layers of frameworks, languages, and
        software products that support the software. Each layer involves a choice in technology. For
        instance, in one layer, you could choose to use one programming language or another.
      </p>

      <p>
        Why is the tech stack set up in layers? Software engineering is built off the idea of
        abstraction. That is, you can assume parts of a system are a black box: you provide certain
        input and get a certain output. This helps break down the problem and reduce the scope of
        different software tasks.
      </p>
      <p>
        For example, I've built a site for song chords, MusicParsed (<a
          href="https://www.musicparsed.com/"
          target="_blank"
          >website link</a
        >, <a href="https://github.com/elainewlin/MusicParsed" target="_blank">source code</a>). The
        tech stack for this project is:
      </p>
      <ol>
        <li>
          <b> HTML, CSS, Javascript: </b>These are the typical front-end technologies used to build
          views and interactions on the web. I use Mustache templates to help structure HTML and
          Typescript, a typed variant of Javascript.
        </li>
        <li>
          <b> Node.js: </b>If you go to a particular URL e.g. /login, Node.js handles making sure
          your request directs you to the correct web page. If you need to talk to the database (DB)
          e.g. adding a new user, Node.js mediates the interactions between the front-end and the
          DB.
        </li>
        <li>
          <b> MongoDB: </b>Websites need to store data somewhere and do so using databases. I use
          MongoDB for storing song data (what are the chords/lyrics of a song?) and user data (how
          can users log in?).
        </li>
        <li>
          <b> Heroku: </b>I use this service to deploy the application (how do I make changes live
          on the actual site?). It handles all the other stuff needed for my website, and I don't
          need to know its internal details.
        </li>
      </ol>

      <p>
        As applications get bigger, one person can't manage everything, so people take roles at the
        different layers. Here's an overview of some types of roles you'll see:
      </p>
      <ul>
        <li>
          Front-end (aka client-side)
          <ul>
            <li>
              This typically refers to front-end web (as opposed to mobile) development because
              mobile development often uses different tools.
            </li>
            <li>
              Common programming languages are HTML, CSS, Javascript and variants thereof.
            </li>
            <li>
              Common tasks involve building page layouts and setting up buttons, text, and other
              components. This also involves improving browser performance and managing client state
              for big apps.
            </li>
          </ul>
        </li>
        <li>
          Mobile
          <ul>
            <li>
              iOS/Android application development.
            </li>
            <li>
              Common programming languages include Java and Kotlin for Android, ObjectiveC and Swift
              for iOS, or Javascript (using React Native) for both.
            </li>
            <li>
              Common tasks are similar to the front-end tasks, but on a mobile app as opposed to a
              website.
            </li>
          </ul>
        </li>
        <li>
          Back-end (aka server-side)
          <ul>
            <li>
              This is sometimes an umbrella term for everything that's not front-end, regardless of
              how far down in the stack.
            </li>
            <li>
              Because of that, it's hard to list common technologies. If a back-end engineer joined
              MusicParsed, they'd work with Node.js and MongoDB and handle those sorts of changes.
            </li>
          </ul>
        </li>
        <li>
          Full-stack
          <ul>
            <li>
              This refers to somebody who does front-end and back-end development. Note that this
              does not include all of the back-end technologies.
            </li>
            <li>
              In the context of MusicParsed, I'd say this includes working with HTML, CSS,
              Javascript on the front-end, Node.js and MongoDB on the back-end.
            </li>
          </ul>
        </li>
      </ul>

      <p>
        Many other roles are also colloquially called back-end. However, this type of back-end
        development is not necessarily included in the scope of a full-stack role. It requires going
        deeper down the tech stack or deeper into how some technologies work. These roles are often
        more senior, but you can get into them by starting with back-end development.
      </p>
      <ul>
        <li>Platform</li>
        <li>Infrastructure</li>
        <li>Database</li>
        <li>Security</li>
        <li>Dev Ops</li>
      </ul>

      <p>
        When reading job descriptions and applying, take the list of formal requirements with a
        grain of salt. You don't need to meet 100% of them to apply. Even if you meet 0% of them,
        the worst thing that could happen is that you get a rejection letter (and you'll get plenty
        of those regardless). However, you can look for roles that are suitable for your general
        skill-level (e.g. internships or new grad roles).
      </p>

      <h3 id="why-fullstack">Why Full-stack for me?</h3>
      <p>
        There are a few sub-decisions behind why I chose full-stack software engineering.
      </p>
      <ol>
        <li>Why computer science?</li>
        <li>Why software (vs. hardware)?</li>
        <li>
          Why applied (vs. theoretical) computer science?
        </li>
        <li>Why full-stack?</li>
      </ol>
      <p>
        If you're in school or taking computer science classes, classes are useful for deciding what
        you like or don't like.
      </p>

      <p><b>1) Why computer science?</b></p>
      <p>
        My decision here was pragmatic. I liked math back in high-school and knew computer science
        was related. My mom was a software engineer, so I thought that software engineering was a
        sensible career choice.
      </p>

      <p><b>2) Why software (vs. hardware)?</b></p>
      <p>
        My college had a combined electrical engineering and computer science field, so I took
        courses that worked with hardware.
      </p>

      <p>
        I don't like dealing with faults in physical objects. Once I had a circuit assignment that
        didn't work. I struggled for an hour or two before a TA tried the same circuit on a
        different circuit board and it worked. I wish the first circuit board could have printed an
        error message instead of failing silently. With software, if there's a bug in code, it's
        usually your fault and not the computer's.
      </p>

      <p>
        <b>3) Why applied (vs. theoretical) computer science?</b>
      </p>
      <p>
        The computer science curriculum in college included both applied and theoretical computer
        science. Theoretical computer science includes algorithms, which are applied math. The
        applied classes involved more hands-on coding.
      </p>

      <p>
        Though many concepts from theoretical computer science have important practical applications
        (e.g. algorithms for encryption or consensus), I didn't see a strong real-world connection
        for a lot of theoretical work. I wanted to build products that people could use, so I chose
        to focus on applied work and software engineering.
      </p>

      <p><b>4) Why full-stack?</b></p>
      <p>
        I started out wanting to be a front-end engineer. I took a class on user experience, and I
        liked thinking about products through a user's perspective. I also liked the immediate and
        obvious feedback loop in front-end development. You can make a change and see it reflected
        on a webpage.
      </p>

      <p>
        However, in order to build more complex products, you need to learn back-end technologies.
        For instance, if you're building a login page, there's more to do than setting up the form
        fields. You need to know how to make the page available on a website, how to handle
        passwords securely, and how to interact with a database. This is how I built the
        <a href="https://www.musicparsed.com/login" target="_blank">login page for MusicParsed</a>.
      </p>

      <h3>Conclusion</h3>
      <p>
        I write about my decision-making process with the clearness of hindsight, and my decisions
        were not half so clear when I first made them. A career is long, and it's okay to take your
        time thinking through different options. If you like software, I hope that this helped you
        think about how to find a specialty in software engineering.
      </p>
    </div>
  </body>
</html>
